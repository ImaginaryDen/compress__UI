#include "fractalcomression.h"
#include <cmath>
#include <numeric>
#include <stdexcept>
#include <vector>

using namespace std;

// ??????? ??? ????????? ??????????? ?? ????? ?????????????? ???????
vector<vector<vector<int>>> splitImage(vector<vector<int>> image, int blockSize)
{
    const int numRows = image.size();
    const int numCols = image[0].size();
    const int numBlocksX = (numCols + blockSize - 1) / blockSize;
    const int numBlocksY = (numRows + blockSize - 1) / blockSize;
    vector<vector<vector<int>>> blocks(numBlocksX, vector<vector<int>>(numBlocksY, vector<int>(blockSize * blockSize)));

    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numCols; j++) {
            int blockRow = i / blockSize;
            int blockCol = j / blockSize;
            int blockIndex = (i % blockSize) * blockSize + j % blockSize;
            blocks[blockRow][blockCol][blockIndex] = image[i][j];
        }
    }

    return blocks;
}

vector<vector<int>> subtractBlocks(vector<vector<int>> block1, vector<vector<int>> block2)
{
    int size = block1.size();
    vector<vector<int>> result(size, vector<int>(size));

    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            result[i][j] = block1[i][j] - block2[i][j];
        }
    }

    return result;
}


// ??????? ??? ?????????? ????????? ???????? ????????????? ??? ?????
void findBestTransform(vector<vector<int>> block, vector<vector<int>> &transform, vector<vector<int>> &residual)
{
    // ?????? ?????
    int size = block.size();

    // ????????? ????? ?? ?????????? ? ??????? ????????
    vector<double> X, Y, R;
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            X.push_back(i);
            Y.push_back(j);
            R.push_back(block[i][j]);
        }
    }

    // ??????? ??????? ???????? ????????? ? ???????
    double meanX = accumulate(X.begin(), X.end(), 0.0) / X.size();
    double meanY = accumulate(Y.begin(), Y.end(), 0.0) / Y.size();
    double meanR = accumulate(R.begin(), R.end(), 0.0) / R.size();

    // ??????? ?????????????? ????????? ? ???????
    vector<double> centeredX, centeredY, centeredR;
    for (int i = 0; i < X.size(); i++)
    {
        centeredX.push_back(X[i] - meanX);
        centeredY.push_back(Y[i] - meanY);
        centeredR.push_back(R[i] - meanR);
    }

    // ??????? ?????????????? ???????
    double xx = 0, yy = 0, xy = 0, xr = 0, yr = 0, rr = 0;
    for (int i = 0; i < centeredX.size(); i++)
    {
        xx += centeredX[i] * centeredX[i];
        yy += centeredY[i] * centeredY[i];
        xy += centeredX[i] * centeredY[i];
        xr += centeredX[i] * centeredR[i];
        yr += centeredY[i] * centeredR[i];
        rr += centeredR[i] * centeredR[i];
    }

    double det = xx * yy - xy * xy;
    if (det == 0)
        throw std::overflow_error("Divide by zero exception");

    // ??????? ????????????? ?????????????
    double a = (yy * xr - xy * yr) / det;
    double b = (xx * yr - xy * xr) / det;
    double c = meanR - a * meanX - b * meanY;

    // ??????? ???????? ????? ?????????? ?????????????
    vector<vector<int>> transformedBlock(size, vector<int>(size));
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            transformedBlock[i][j] = round(a * i + b * j + c);
        }
    }

    // ?????? ??????????
    transform = {{static_cast<int>(round(a * 100)), static_cast<int>(round(b * 100)), static_cast<int>(round(c))}, {0, 0, 1}};
    residual = subtractBlocks(block, transformedBlock);
}

// ??????? ??? ??????????? ?????????? ????????????? ? ????????
void encode(vector<vector<int>> transform, vector<vector<int>> residual, vector<int> &output)
{
    // ???????? ????????? ?????????????
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            output.push_back(transform[i][j]);
        }
    }

    // ???????? ???????
    for (int i = 0; i < residual.size(); i++)
    {
        for (int j = 0; j < residual.size(); j++)
        {
            output.push_back(residual[i][j]);
        }
    }
}

// ???????? ??????? ?????? ???????????
void compress(vector<vector<int>> image, int blockSize, vector<int> &output)
{
    // ????????? ??????????? ?? ????? ?????????????? ???????
    vector<vector<vector<int>>> blocks = splitImage(image, blockSize);

    // ??????????? ?????????? ????????????? ? ???????? ??? ??????? ?????
    for (auto block : blocks)
    {
        vector<vector<int>> transform, residual;
        findBestTransform(block, transform, residual);
        encode(transform, residual, output);
    }
}

FractalComression::FractalComression()
{

}

void FractalComression::Comression()
{
    // compress()
}
